{"version":3,"sources":["update-model.js","unique-window-identifier.js","angular-sync-local-storage.js"],"names":[],"mappings":"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","file":"angular-sync-local-storage.js","sourcesContent":["\"use strict\";\n\nif(!window.taylorcode) window.taylorcode = {}\n\ntaylorcode.updateModel = updateModel;\n\nfunction updateModel(oldObj, newObj) {\n\n   if (oldObj.constructor !== newObj.constructor) {\n      throw new Error(\"updateModel: both arguments passed must be of the same type.\");\n   }\n   if (!oldObj instanceof Object) {\n      throw new Error(\"updateModel: arguments passed cannot be primitive.\");\n   }\n\n   function compareElementsAtKey(key) {\n      // property simply doesn't exist in the new object\n      if (!oldObj[key]) {\n         oldObj[key] = newObj[key];\n      } else\n         // they are both either arrays or hashes, and are not of primitive types\n         if (oldObj[key].constructor === newObj[key].constructor && oldObj[key] instanceof Object) {\n            updateModel(oldObj[key], newObj[key]);\n         } else if (oldObj[key] !== newObj[key]) {\n            // all this compares is if primitives are equal, don't reassign\n            oldObj[key] = newObj[key];\n         }\n   }\n\n   if (oldObj instanceof Array) {\n      // we can assume at this point that they are both arrays\n      if (oldObj.length > newObj.length) {\n         oldObj.length = newObj.length // actually mutate the length of the old object -- remove the items that are not in it\n         ;\n      }\n      // the lengths are the same - one to one with new and old object\n      for (var i = 0; i < newObj.length; i++) {\n         compareElementsAtKey(i);\n      }\n   } else {\n      // we can assume that they are both objects\n      // if the old object has any properties that are not in the new object, remove them\n      for (var oldProp in oldObj) {\n         if (!newObj.hasOwnProperty(oldProp)) {\n            delete oldObj[oldProp];\n         }\n      }\n      // now the properties are the same between new and old object\n      for (var prop in newObj) {\n         compareElementsAtKey(prop);\n      }\n   }\n}\n//# sourceMappingURL=update-model.js.map","\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar UniqueWindowIdentifier = (function () {\n  function UniqueWindowIdentifier($window) {\n    _classCallCheck(this, UniqueWindowIdentifier);\n\n    this.$window = $window;\n    this.currentWindow = this.$window.self;\n    this.nameKey = \"__uniqueWindowIdentifier\";\n  }\n\n  _createClass(UniqueWindowIdentifier, {\n    _generateUniqueId: {\n      value: function _generateUniqueId() {\n        return Math.random().toString(36).slice(2);\n      }\n    },\n    _setIdentifier: {\n      value: function _setIdentifier(nameObj) {\n        var windowNameObj = nameObj || {};\n        windowNameObj[this.nameKey] = this._generateUniqueId();\n        this.currentWindow.name = JSON.stringify(windowNameObj);\n      }\n    },\n    ensure: {\n      value: function ensure() {\n        var windowNameObj;\n        // if windowProps.name is set and it's not a stringified object, convert it to it\n        if (this.currentWindow.name) {\n          try {\n            windowNameObj = JSON.parse(this.currentWindow.name);\n          } catch (e) {\n            // the name is not a stringified object\n            console.warn(\"UniqueWindowIdentifier: the windows name is already set, overriding with an stringified object\");\n            this._setIdentifier();\n            return;\n          }\n          // what's saved is a stringifed object already\n          if (!windowNameObj[this.nameKey]) {\n            this._setIdentifier(windowNameObj);\n          }\n        } else {\n          this._setIdentifier();\n        }\n      }\n    },\n    reset: {\n      value: function reset() {\n        this._setIdentifier();\n      }\n    },\n    get: {\n      value: function get() {\n        // return the identifier or undefined\n        var identifier;\n        try {\n          identifier = JSON.parse(this.currentWindow.name)[this.nameKey];\n        } catch (e) {\n          return;\n        }\n        return identifier;\n      }\n    }\n  });\n\n  return UniqueWindowIdentifier;\n})();\n\nangular.module(\"angularUniqueWindow\", []).service(\"uniqueWindowIdentifier\", UniqueWindowIdentifier);\n//# sourceMappingURL=unique-window-identifier.js.map","/**\n * @ngdoc provider\n * @name AngularSyncLocalStorageProviderFactory\n *\n * @description\n * Allows configuration of an instance of AngularSyncLocalStorage.\n * \n */\nexport function AngularSyncLocalStorageProviderFactory () {\n  return new AngularSyncLocalStorageProvider\n}\n\n/**\n * @ngdoc class\n * @name AngularSyncLocalStorageProvider\n *\n * @description\n * Class definition for the `AngularSyncLocalStorage` provider. \n * \n */\nclass AngularSyncLocalStorageProvider {\n  constructor() {\n    this.debounceSyncDelay = 300\n  }\n  $get($rootScope, $window, $timeout, uniqueWindowIdentifier) {\n    return new AngularSyncLocalStorage($rootScope, $window, $timeout, uniqueWindowIdentifier, this) // pass in the provider instance\n  }\n}\n\n/**\n * @ngdoc service\n * @name AngularSyncLocalStorage\n *\n * @description\n * Service that enables automatic synchronization of a local object with `localStorage`. Also supports\n * synchronization across browser windows, the creation of unique `localStorage` containers per window,\n * and new containers to be created from a master.\n * \n */\nclass AngularSyncLocalStorage {\n\n  constructor($rootScope, $window, $timeout, uniqueWindowIdentifier, providerInstance) {\n    this.$rootScope = $rootScope\n    this.$window = $window\n    this.$timeout = $timeout\n    this.localStorage = $window.localStorage\n    this.providerInstance = providerInstance\n    this.uniqueWindowIdentifier = uniqueWindowIdentifier\n    this._masterKeyPostfix = '__master'\n    this.syncMap = {}\n    this.localMap = {}\n  }\n\n  /**\n   * @ngdoc method\n   * @private\n   * @name AngularSyncLocalStorage#_supportsLocalStorage\n   *\n   * @description\n   * Determines if the device supports localStorage.\n   * \n   * @returns {Bool} true if the device supports localStorage\n   */\n  _supportsLocalStorage() {\n    var testKey = 'test',\n        storage = window.localStorage\n    try {\n      storage.setItem(testKey, '1')\n      storage.removeItem(testKey)\n      return true\n    } catch (error) {\n      return false\n    } \n  }\n\n  /**\n   * @ngdoc method\n   * @private\n   * @name AngularSyncLocalStorage#_debounce\n   *\n   * @description\n   * Creates and returns a new debounced version of the passed function which \n   * will postpone its execution until after wait milliseconds have elapsed \n   * since the last time it was invoked.\n   *\n   * @param {Function} func The function that will be wrapped and be postponed\n   * @param {Number} wait The minimum time in MS that the function will be called\n   * @param {Bool} immediate If true the first time the returned function is called `func` will be invoked\n   * @returns {Function} A function that when called, will postpone execution of `func` as described\n   */\n  _debounce(func, wait, immediate) {\n    var timeout\n    return function() {\n      var context = this, args = arguments\n      var later = function() {\n        timeout = null\n        if (!immediate) func.apply(context, args)\n      }\n      var callNow = immediate && !timeout\n      clearTimeout(timeout)\n      timeout = setTimeout(later, wait)\n      if (callNow) func.apply(context, args)\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @private\n   * @name AngularSyncLocalStorage#_updateLocalStorage\n   *\n   * @description\n   * Updates `localStorage` with an objects value\n   *\n   * @param {String} key The key to update in localStorage with the stringified `value`\n   * @param {Object} value The value that will be stringified.\n   */\n  _updateLocalStorage(key, value) {\n    this.localStorage[key] = angular.toJson(value)\n  }\n\n  /**\n   * @ngdoc method\n   * @private\n   * @name AngularSyncLocalStorage#_autoSyncExternalUpdates\n   *\n   * @description\n   * Creates an event listener for external changes to `localStorage`. Synchronizes\n   * the value from `localStorage` into a local object. Broadcasts an `sls:updated` event\n   * with the key that is updated.\n   *\n   * @param {Function} syncLocal Pre-bound function that when called, performs the synchronization\n   * @param {String} persistKey The name of the `localStorage` property that will be notified as updated\n   */\n  _autoSyncExternalUpdates(syncLocal, persistKey) {\n    // bind a new event listener for this local object and persist key\n    this.$window.addEventListener('storage', () => {\n      if(syncLocal()) {\n        // NOTE timeout is needed because this has the potential to be broadcasted before the ready.\n        // on updated occurs when localStorage is updated outside of the application\n        // and you may have services that need to query the data (such as session information)\n        this.$timeout(() => {\n          this.$rootScope.$broadcast('sls:updated', {\n            key: persistKey\n          })\n        })\n        this.$rootScope.$digest()\n      }\n    })\n  }\n\n  /**\n   * @ngdoc method\n   * @private\n   * @name AngularSyncLocalStorage#_sync\n   *\n   * @description\n   * Creates a function that when called, updates values from a deserialized `localStorage` \n   * key (object) with an object, without destroying any references.\n   *\n   * @param {Object} storageService The storage mechanism, `localStorage` is used\n   * @param {String} key The name of the property in the `storageService`\n   * @param {Object} localObject The object that will be updated\n   * @returns {Function} The function that performs the updates\n   */\n  _sync(storageService, key, localObject) {\n    return () => {\n      var fromStorageContainer\n      // if there's no container (such as localStorage, then create it)\n      if(!storageService[key]) {\n        return false\n      } else {\n        fromStorageContainer = angular.fromJson(storageService[key])\n        // if the storage containers stuff isn't the same as the local object\n        if (!angular.equals(localObject, fromStorageContainer)) {\n          // update the local object with the storage containers stuff\n          taylorcode.updateModel(localObject, fromStorageContainer)\n          return true\n        }\n        return false\n      }\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @private\n   * @name AngularSyncLocalStorage#_mirrorLocalStorage\n   *\n   * @description\n   * Creates a function that when called, updates the key in `localStorage` with an\n   * object, if the object was updated. Also updates a key that serves the purpose of\n   * as master container that will contain the most recently updated copy of the\n   * containers. Used when windows have unique `localStorage` containers all of the\n   * same group of data, but upon creation of a new window, you want the most recently\n   * updated version of the data group to populate the new windows `localStorage` container\n   *\n   * @param {String} persistKey The storage mecha\n   * @param {String} masterKey They key in `localStorage` that stores the master copy\n   * @param {Bool} trackMaster Indicates if the master for this `localStorage` container should update\n   */\n  _mirrorLocalStorage(persistKey, masterKey, trackMaster) {\n    return (ls, oldLs) => {\n      if(ls === oldLs) {\n        // if it's the same object (nothing has changed), just return\n        return\n      }\n      this._updateLocalStorage(persistKey, ls)\n      if(trackMaster) {\n        // update the master so it always has the most recent data\n        this._updateLocalStorage(masterKey, ls)\n      }\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @name AngularSyncLocalStorage#syncLocalObj\n   *\n   * @description\n   * Updates a `localStorage` container with the values from an object if the container is\n   * mapped to the object.\n   * \n   * @param {Object} localObject The object that is mapped to a `localStorage` container\n   * @param {String} masterKey They key in `localStorage` that stores the master copy\n   * @returns {Object|undefined} The mapped object if it is found in localStorage, or undefined if not found\n   */\n  syncLocalObj(localObject) {\n    for(var key in this.localMap) {\n      if(this.localMap[key] === localObject) {\n        return this.syncMap[key](localObject)\n      }\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @name AngularSyncLocalStorage#synchronize\n   *\n   * @description\n   * Configures automatic synchronization between an object and a `localStorage` container\n   * \n   * @param {Object} localObject The object that is synchronized the `localStorage` container\n   * @param {String} persistKey They key for this container or group of containers\n   * @param {Object} ops A map of options for configuring the behaviour of the synchronization\n   * @param {Bool} ops.uniquePerWindow If true, the localStorage container will persist in each browser window, \n   *   but not between windows.\n   * @param {Bool} ops.restoreFromMaster If `uniquePerWindow` and `restoreFromMaster` and `initialSync` are all \n   *   true, when a new window is created, its unique `localStorage` container will be initialized with the most \n   *   recently synchronized values to any of the unique window containers for the `localStorageKey`.\n   * @param {Bool} ops.initialSync If true, the container will be synchronized with localStorage when it is \n   *   initialized. Otherwise, the reverse will happen; localStorage will be synchronized with the object.\n   */\n  synchronize(localObject, persistKey, ops) {\n\n    let localObjStringType = Object.prototype.toString.call(localObject)\n    // only handle synchronization of hashes or arrays\n    if(localObjStringType !== '[object Object]' && localObjStringType !== '[object Array]') {\n      throw new Error('AngularSyncLocalStorage: object to synchronize with must be an hash or an array.')\n    }\n    // default options\n    var options = {\n      uniquePerWindow: false,\n      restoreFromMaster: true,\n      initialSync: true\n    },\n    syncLocal = null,\n    synchronizeLocalStorage, trackMaster, masterKey\n\n    if(!this.supportsLocalStorage()) {\n      // silently die if there is no localStorage support\n      return\n    }\n    // merge options into default options\n    angular.extend(options, ops)\n\n    trackMaster = options.uniquePerWindow && options.restoreFromMaster && options.initialSync\n\n    if(options.uniquePerWindow) {\n      // create or just make sure the window has it's unique identifier\n      this.uniqueWindowIdentifier.ensure()\n      // create a master key that will be used when creating new windows\n      masterKey = persistKey + this._masterKeyPostfix\n      // modify the key so that it uses a unique store for this window\n      persistKey += '_' + this.uniqueWindowIdentifier.get()\n    }\n\n    // at this point, the persist key is what we're going to want to synchronize with\n    syncLocal = this._sync(this.localStorage, persistKey, localObject)\n\n    if (options.initialSync) {\n      // if we want to track master, we don't already have a value for this key, and master has a value\n      // then make the new container a copy of master\n      if (trackMaster && !this.localStorage[persistKey] && this.localStorage[masterKey]) {\n        // restore the master onto this local\n        this.localStorage[persistKey] = this.localStorage[masterKey]\n      }\n      // finally take what's in localStorage at this key now, and sync it to the local object\n      syncLocal()\n    }\n    // create a map of key --> sync functions\n    this.syncMap[persistKey] = this._mirrorLocalStorage(persistKey, masterKey, trackMaster)\n    // set up to update localStorage only every debounce time\n    // only affects performance of the other windows receiving the update\n    // initially update if we haven't already synchronized ls --> obj\n    synchronizeLocalStorage = this.debounce(this.syncMap[persistKey], this.providerInstance.debounceSyncDelay, !options.initialSync)\n    this.localMap[persistKey] = localObject\n    // deep watch localObject for changes, update localStorage when whey occur\n    this.$rootScope.$watch(() => {\n      return localObject\n    }, synchronizeLocalStorage, true)\n\n    // auto synchronize the data from other windows if the container is not unique-per window\n    if(!options.uniquePerWindow) {\n      this._autoSyncExternalUpdates(syncLocal, persistKey)\n    }\n  }\n}"],"sourceRoot":"/source/"}