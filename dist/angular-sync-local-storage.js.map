{"version":3,"sources":["node_modules/bundler-js/node_modules/browserify/node_modules/browser-pack/_prelude.js","angular-sync-local-storage.js","src/module.js","src/angular-sync-local-storage.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"_interopRequire","obj","__esModule","AngularSyncLocalStorageProviderFactory","angular","module","provider","./angular-sync-local-storage",2,"AngularSyncLocalStorageProvider","_createClass","defineProperties","target","props","key","prop","configurable","value","writable","Object","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","this","debounceSyncDelay","$get","$rootScope","$window","$timeout","uniqueWindowIdentifier","AngularSyncLocalStorage","providerInstance","localStorage","_masterKeyPostfix","_versionKeyPostfix","syncMap","localMap","_supportsLocalStorage","testKey","storage","setItem","removeItem","error","_debounce","func","wait","immediate","timeout","context","args","arguments","later","apply","callNow","clearTimeout","setTimeout","_updateLocalStorage","toJson","_autoSyncExternalUpdates","syncLocal","persistKey","_this","addEventListener","$broadcast","$digest","_sync","storageService","localObject","fromStorageContainer","fromJson","equals","taylorcode","updateModel","_mirrorLocalStorage","masterKey","trackMaster","ls","oldLs","syncLocalObj","synchronize","ops","localObjStringType","toString","synchronizeLocalStorage","versionKey","options","uniquePerWindow","restoreFromMaster","initialSync","version","isNewLsVersion","extend","ensure","get","$watch"],"mappings":"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","file":"angular-sync-local-storage.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",null,"import AngularSyncLocalStorageProviderFactory from './angular-sync-local-storage'\n\nangular.module('angularSyncLocalStorage', ['angularUniqueWindow'])\n\n.provider('synchronizedLocalStorage', AngularSyncLocalStorageProviderFactory)\n","/**\n * @ngdoc provider\n * @name AngularSyncLocalStorageProviderFactory\n *\n * @description\n * Allows configuration of an instance of AngularSyncLocalStorage.\n * \n */\nexport default function AngularSyncLocalStorageProviderFactory () {\n  return new AngularSyncLocalStorageProvider\n}\n\n/**\n * @ngdoc class\n * @name AngularSyncLocalStorageProvider\n *\n * @description\n * Class definition for the `AngularSyncLocalStorage` provider. \n * \n */\nclass AngularSyncLocalStorageProvider {\n  constructor() {\n    this.debounceSyncDelay = 300\n  }\n  $get($rootScope, $window, $timeout, uniqueWindowIdentifier) {\n    return new AngularSyncLocalStorage($rootScope, $window, $timeout, uniqueWindowIdentifier, this) // pass in the provider instance\n  }\n}\n\n/**\n * @ngdoc service\n * @name AngularSyncLocalStorage\n *\n * @description\n * Service that enables automatic synchronization of a local object with `localStorage`. Also supports\n * synchronization across browser windows, the creation of unique `localStorage` containers per window,\n * and new containers to be created from a master.\n * \n */\nclass AngularSyncLocalStorage {\n\n  constructor($rootScope, $window, $timeout, uniqueWindowIdentifier, providerInstance) {\n    this.$rootScope = $rootScope\n    this.$window = $window\n    this.$timeout = $timeout\n    this.localStorage = $window.localStorage\n    this.providerInstance = providerInstance\n    this.uniqueWindowIdentifier = uniqueWindowIdentifier\n    this._masterKeyPostfix = '__master'\n    this._versionKeyPostfix = '__version'\n    this.syncMap = {}\n    this.localMap = {}\n  }\n\n  /**\n   * @ngdoc method\n   * @private\n   * @name AngularSyncLocalStorage#_supportsLocalStorage\n   *\n   * @description\n   * Determines if the device supports localStorage.\n   * \n   * @returns {Bool} true if the device supports localStorage\n   */\n  _supportsLocalStorage() {\n    var testKey = 'test',\n        storage = this.$window.localStorage\n    try {\n      storage.setItem(testKey, '1')\n      storage.removeItem(testKey)\n      return true\n    } catch (error) {\n      return false\n    } \n  }\n\n  /**\n   * @ngdoc method\n   * @private\n   * @name AngularSyncLocalStorage#_debounce\n   *\n   * @description\n   * Creates and returns a new debounced version of the passed function which \n   * will postpone its execution until after wait milliseconds have elapsed \n   * since the last time it was invoked.\n   *\n   * @param {Function} func The function that will be wrapped and be postponed\n   * @param {Number} wait The minimum time in MS that the function will be called\n   * @param {Bool} immediate If true the first time the returned function is called `func` will be invoked\n   * @returns {Function} A function that when called, will postpone execution of `func` as described\n   */\n  _debounce(func, wait, immediate) {\n    var timeout\n    return function() {\n      var context = this, args = arguments\n      var later = function() {\n        timeout = null\n        if (!immediate) func.apply(context, args)\n      }\n      var callNow = immediate && !timeout\n      clearTimeout(timeout)\n      timeout = setTimeout(later, wait)\n      if (callNow) func.apply(context, args)\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @private\n   * @name AngularSyncLocalStorage#_updateLocalStorage\n   *\n   * @description\n   * Updates `localStorage` with an objects value\n   *\n   * @param {String} key The key to update in localStorage with the stringified `value`\n   * @param {Object} value The value that will be stringified.\n   */\n  _updateLocalStorage(key, value) {\n    this.localStorage[key] = angular.toJson(value)\n  }\n\n  /**\n   * @ngdoc method\n   * @private\n   * @name AngularSyncLocalStorage#_autoSyncExternalUpdates\n   *\n   * @description\n   * Creates an event listener for external changes to `localStorage`. Synchronizes\n   * the value from `localStorage` into a local object. Broadcasts an `sls:updated` event\n   * with the key that is updated.\n   *\n   * @param {Function} syncLocal Pre-bound function that when called, performs the synchronization\n   * @param {String} persistKey The name of the `localStorage` property that will be notified as updated\n   */\n  _autoSyncExternalUpdates(syncLocal, persistKey) {\n    // bind a new event listener for this local object and persist key\n    this.$window.addEventListener('storage', () => {\n      if(syncLocal()) {\n        // NOTE timeout is needed because this has the potential to be broadcasted before the ready.\n        // on updated occurs when localStorage is updated outside of the application\n        // and you may have services that need to query the data (such as session information)\n        this.$timeout(() => {\n          this.$rootScope.$broadcast('sls:updated', {\n            key: persistKey\n          })\n        })\n        this.$rootScope.$digest()\n      }\n    })\n  }\n\n  /**\n   * @ngdoc method\n   * @private\n   * @name AngularSyncLocalStorage#_sync\n   *\n   * @description\n   * Creates a function that when called, updates values from a deserialized `localStorage` \n   * key (object) with an object, without destroying any references.\n   *\n   * @param {Object} storageService The storage mechanism, `localStorage` is used\n   * @param {String} key The name of the property in the `storageService`\n   * @param {Object} localObject The object that will be updated\n   * @returns {Function} The function that performs the updates\n   */\n  _sync(storageService, key, localObject) {\n    return () => {\n      var fromStorageContainer\n      // if there's no container (such as localStorage, then create it)\n      if(!storageService[key]) {\n        return false\n      } else {\n        fromStorageContainer = angular.fromJson(storageService[key])\n        // if the storage containers stuff isn't the same as the local object\n        if (!angular.equals(localObject, fromStorageContainer)) {\n          // update the local object with the storage containers stuff\n          taylorcode.updateModel(localObject, fromStorageContainer)\n          return true\n        }\n        return false\n      }\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @private\n   * @name AngularSyncLocalStorage#_mirrorLocalStorage\n   *\n   * @description\n   * Creates a function that when called, updates the key in `localStorage` with an\n   * object, if the object was updated. Also updates a key that serves the purpose of\n   * as master container that will contain the most recently updated copy of the\n   * containers. Used when windows have unique `localStorage` containers all of the\n   * same group of data, but upon creation of a new window, you want the most recently\n   * updated version of the data group to populate the new windows `localStorage` container\n   *\n   * @param {String} persistKey The storage mecha\n   * @param {String} masterKey They key in `localStorage` that stores the master copy\n   * @param {Bool} trackMaster Indicates if the master for this `localStorage` container should update\n   */\n  _mirrorLocalStorage(persistKey, masterKey, trackMaster) {\n    return (ls, oldLs) => {\n      if(ls === oldLs) {\n        // if it's the same object (nothing has changed), just return\n        return\n      }\n      this._updateLocalStorage(persistKey, ls)\n      if(trackMaster) {\n        // update the master so it always has the most recent data\n        this._updateLocalStorage(masterKey, ls)\n      }\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @name AngularSyncLocalStorage#syncLocalObj\n   *\n   * @description\n   * Updates a `localStorage` container with the values from an object if the container is\n   * mapped to the object.\n   * \n   * @param {Object} localObject The object that is mapped to a `localStorage` container\n   * @param {String} masterKey They key in `localStorage` that stores the master copy\n   * @returns {Object|undefined} The mapped object if it is found in localStorage, or undefined if not found\n   */\n  syncLocalObj(localObject) {\n    for(var key in this.localMap) {\n      if(this.localMap[key] === localObject) {\n        return this.syncMap[key](localObject)\n      }\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @name AngularSyncLocalStorage#synchronize\n   *\n   * @description\n   * Configures automatic synchronization between an object and a `localStorage` container\n   * \n   * @param {Object} localObject The object that is synchronized the `localStorage` container\n   * @param {String} persistKey They key for this container or group of containers\n   * @param {Object} ops A map of options for configuring the behaviour of the synchronization\n   * @param {Bool} ops.uniquePerWindow If true, the localStorage container will persist in each browser window, \n   *   but not between windows.\n   * @param {Bool} ops.restoreFromMaster If `uniquePerWindow` and `restoreFromMaster` and `initialSync` are all \n   *   true, when a new window is created, its unique `localStorage` container will be initialized with the most \n   *   recently synchronized values to any of the unique window containers for the `localStorageKey`.\n   * @param {Bool} ops.initialSync If true, the container will be synchronized with localStorage when it is \n   *   initialized. Otherwise, the reverse will happen; localStorage will be synchronized with the object.\n   */\n  synchronize(localObject, persistKey, ops) {\n\n    let localObjStringType = Object.prototype.toString.call(localObject)\n    // only handle synchronization of hashes or arrays\n    if(localObjStringType !== '[object Object]' && localObjStringType !== '[object Array]') {\n      throw new Error('AngularSyncLocalStorage: object to synchronize with must be an hash or an array.')\n    }\n    // default options\n    var options = {\n      uniquePerWindow: false,\n      restoreFromMaster: true,\n      initialSync: true,\n      version: 0\n    },\n    syncLocal = null,\n    isNewLsVersion = false,\n    synchronizeLocalStorage, trackMaster, masterKey, versionKey\n\n    if(!this._supportsLocalStorage()) {\n      // silently die if there is no localStorage support\n      return\n    }\n    // merge options into default options\n    angular.extend(options, ops)\n\n    trackMaster = options.uniquePerWindow && options.restoreFromMaster && options.initialSync\n\n    if(options.version) {\n      versionKey = persistKey + this._versionKeyPostfix\n      if(options.version !== this.localStorage[versionKey]) {\n        // set that this is a new localStorage version\n        isNewLsVersion = true\n        // finally, update the version in localStorage\n        this.localStorage[versionKey] = options.version\n      }\n      // they are equal, do nothing\n    }\n\n    if(options.uniquePerWindow) {\n      // create or just make sure the window has it's unique identifier\n      this.uniqueWindowIdentifier.ensure()\n      // create a master key that will be used when creating new windows\n      masterKey = persistKey + this._masterKeyPostfix\n      // modify the key so that it uses a unique store for this window\n      persistKey += '_' + this.uniqueWindowIdentifier.get()\n    }\n\n    // remove the containers if it's a new version\n    if(isNewLsVersion) {\n      delete localStorage[persistKey]\n      if(masterKey) {\n        delete localStorage[masterKey]\n      }\n    }\n\n    // at this point, the persist key is what we're going to want to synchronize with\n    syncLocal = this._sync(this.localStorage, persistKey, localObject)\n\n    if (options.initialSync) {\n      // if we want to track master, we don't already have a value for this key, and master has a value\n      // then make the new container a copy of master\n      if (trackMaster && !this.localStorage[persistKey] && this.localStorage[masterKey]) {\n        // restore the master onto this local\n        this.localStorage[persistKey] = this.localStorage[masterKey]\n      }\n      // finally take what's in localStorage at this key now, and sync it to the local object\n      syncLocal()\n    }\n    // create a map of key --> sync functions\n    this.syncMap[persistKey] = this._mirrorLocalStorage(persistKey, masterKey, trackMaster)\n    // set up to update localStorage only every debounce time\n    // only affects performance of the other windows receiving the update\n    // initially update if we haven't already synchronized ls --> obj\n    synchronizeLocalStorage = this._debounce(this.syncMap[persistKey], this.providerInstance.debounceSyncDelay, !options.initialSync)\n    this.localMap[persistKey] = localObject\n    // deep watch localObject for changes, update localStorage when whey occur\n    this.$rootScope.$watch(() => {\n      return localObject\n    }, synchronizeLocalStorage, true)\n\n    // auto synchronize the data from other windows if the container is not unique-per window\n    if(!options.uniquePerWindow) {\n      this._autoSyncExternalUpdates(syncLocal, persistKey)\n    }\n  }\n}"],"sourceRoot":"/source/"}